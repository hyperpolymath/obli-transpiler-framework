// SPDX-License-Identifier: MIT OR AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2024-2025 hyperpolymath

//! Rust code emitter for oblivious IR.
//!
//! Emits Rust code using constant-time primitives.

use crate::ir::{ObliBinOp, ObliExpr, ObliUnaryOp};

/// Emit Rust code from oblivious IR.
pub fn emit_rust(expr: &ObliExpr) -> String {
    let mut emitter = RustEmitter::new();
    emitter.emit_program(expr)
}

struct RustEmitter {
    indent: usize,
}

impl RustEmitter {
    fn new() -> Self {
        Self { indent: 0 }
    }

    fn emit_program(&mut self, expr: &ObliExpr) -> String {
        let mut output = String::new();

        // Header with runtime support
        output.push_str(RUNTIME_PRELUDE);
        output.push_str("\n");

        // Main function
        output.push_str("fn main() {\n");
        self.indent += 1;

        let result = self.emit_expr(expr);
        output.push_str(&self.indented(&format!("let result = {};\n", result)));
        output.push_str(&self.indented("println!(\"Result: {:?}\", result);\n"));

        self.indent -= 1;
        output.push_str("}\n");

        output
    }

    fn emit_expr(&mut self, expr: &ObliExpr) -> String {
        match expr {
            ObliExpr::PubInt(n) => format!("Pub::new({}i64)", n),
            ObliExpr::PubBool(b) => format!("Pub::new({})", b),
            ObliExpr::SecretInt(n) => format!("Secret::new({}i64)", n),
            ObliExpr::SecretBool(b) => format!("Secret::new({})", b),
            ObliExpr::Var { name, .. } => name.clone(),
            ObliExpr::BinOp {
                op, left, right, ..
            } => {
                let left_code = self.emit_expr(left);
                let right_code = self.emit_expr(right);
                let method = binop_method(op);
                format!("{}.{}(&{})", left_code, method, right_code)
            }
            ObliExpr::UnaryOp { op, expr, .. } => {
                let expr_code = self.emit_expr(expr);
                let method = unaryop_method(op);
                format!("{}.{}()", expr_code, method)
            }
            ObliExpr::CtSelect {
                cond,
                then_val,
                else_val,
            } => {
                let cond_code = self.emit_expr(cond);
                let then_code = self.emit_expr(then_val);
                let else_code = self.emit_expr(else_val);
                format!(
                    "ct_select(&{}, &{}, &{})",
                    cond_code, then_code, else_code
                )
            }
            ObliExpr::PubIf {
                cond,
                then_branch,
                else_branch,
            } => {
                let cond_code = self.emit_expr(cond);
                let then_code = self.emit_expr(then_branch);
                let else_code = self.emit_expr(else_branch);
                format!(
                    "if {}.reveal() {{ {} }} else {{ {} }}",
                    cond_code, then_code, else_code
                )
            }
            ObliExpr::Let {
                name, value, body, ..
            } => {
                let value_code = self.emit_expr(value);
                let body_code = self.emit_expr(body);
                format!("{{ let {} = {}; {} }}", name, value_code, body_code)
            }
        }
    }

    fn indented(&self, s: &str) -> String {
        let indent = "    ".repeat(self.indent);
        format!("{}{}", indent, s)
    }
}

fn binop_method(op: &ObliBinOp) -> &'static str {
    match op {
        ObliBinOp::CtAdd => "ct_add",
        ObliBinOp::CtSub => "ct_sub",
        ObliBinOp::CtMul => "ct_mul",
        ObliBinOp::CtDiv => "ct_div",
        ObliBinOp::CtMod => "ct_mod",
        ObliBinOp::CtEq => "ct_eq",
        ObliBinOp::CtNe => "ct_ne",
        ObliBinOp::CtLt => "ct_lt",
        ObliBinOp::CtLe => "ct_le",
        ObliBinOp::CtGt => "ct_gt",
        ObliBinOp::CtGe => "ct_ge",
        ObliBinOp::CtAnd => "ct_and",
        ObliBinOp::CtOr => "ct_or",
    }
}

fn unaryop_method(op: &ObliUnaryOp) -> &'static str {
    match op {
        ObliUnaryOp::CtNeg => "ct_neg",
        ObliUnaryOp::CtNot => "ct_not",
    }
}

/// Runtime prelude - defines Secret, Pub, and ct_select
const RUNTIME_PRELUDE: &str = r#"// SPDX-License-Identifier: MIT OR AGPL-3.0-or-later
// Generated by obli-transpiler

/// Public value wrapper
#[derive(Debug, Clone, Copy)]
struct Pub<T>(T);

/// Secret value wrapper - operations are constant-time
#[derive(Debug, Clone, Copy)]
struct Secret<T>(T);

impl<T> Pub<T> {
    fn new(v: T) -> Self { Pub(v) }
    fn reveal(&self) -> &T { &self.0 }
}

impl<T> Secret<T> {
    fn new(v: T) -> Self { Secret(v) }
    #[allow(dead_code)]
    fn reveal(&self) -> &T { &self.0 } // Use cautiously!
}

// Constant-time operations for i64
impl Pub<i64> {
    fn ct_add(&self, other: &Self) -> Pub<i64> { Pub(self.0.wrapping_add(other.0)) }
    fn ct_sub(&self, other: &Self) -> Pub<i64> { Pub(self.0.wrapping_sub(other.0)) }
    fn ct_mul(&self, other: &Self) -> Pub<i64> { Pub(self.0.wrapping_mul(other.0)) }
    fn ct_div(&self, other: &Self) -> Pub<i64> { Pub(self.0.wrapping_div(other.0)) }
    fn ct_mod(&self, other: &Self) -> Pub<i64> { Pub(self.0.wrapping_rem(other.0)) }
    fn ct_eq(&self, other: &Self) -> Pub<bool> { Pub(self.0 == other.0) }
    fn ct_ne(&self, other: &Self) -> Pub<bool> { Pub(self.0 != other.0) }
    fn ct_lt(&self, other: &Self) -> Pub<bool> { Pub(self.0 < other.0) }
    fn ct_le(&self, other: &Self) -> Pub<bool> { Pub(self.0 <= other.0) }
    fn ct_gt(&self, other: &Self) -> Pub<bool> { Pub(self.0 > other.0) }
    fn ct_ge(&self, other: &Self) -> Pub<bool> { Pub(self.0 >= other.0) }
    fn ct_neg(&self) -> Pub<i64> { Pub(-self.0) }
}

impl Secret<i64> {
    fn ct_add(&self, other: &Self) -> Secret<i64> { Secret(self.0.wrapping_add(other.0)) }
    fn ct_sub(&self, other: &Self) -> Secret<i64> { Secret(self.0.wrapping_sub(other.0)) }
    fn ct_mul(&self, other: &Self) -> Secret<i64> { Secret(self.0.wrapping_mul(other.0)) }
    fn ct_div(&self, other: &Self) -> Secret<i64> { Secret(self.0.wrapping_div(other.0)) }
    fn ct_mod(&self, other: &Self) -> Secret<i64> { Secret(self.0.wrapping_rem(other.0)) }
    fn ct_eq(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 == other.0) }
    fn ct_ne(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 != other.0) }
    fn ct_lt(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 < other.0) }
    fn ct_le(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 <= other.0) }
    fn ct_gt(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 > other.0) }
    fn ct_ge(&self, other: &Pub<i64>) -> Secret<bool> { Secret(self.0 >= other.0) }
    fn ct_neg(&self) -> Secret<i64> { Secret(-self.0) }
}

impl Pub<bool> {
    fn ct_and(&self, other: &Self) -> Pub<bool> { Pub(self.0 & other.0) }
    fn ct_or(&self, other: &Self) -> Pub<bool> { Pub(self.0 | other.0) }
    fn ct_not(&self) -> Pub<bool> { Pub(!self.0) }
}

impl Secret<bool> {
    fn ct_and(&self, other: &Self) -> Secret<bool> { Secret(self.0 & other.0) }
    fn ct_or(&self, other: &Self) -> Secret<bool> { Secret(self.0 | other.0) }
    fn ct_not(&self) -> Secret<bool> { Secret(!self.0) }
}

/// Constant-time select: returns `then_val` if `cond` is true, else `else_val`.
/// CRITICAL: Both branches are always evaluated to prevent timing leaks.
fn ct_select<T: Copy>(cond: &Secret<bool>, then_val: &Secret<T>, else_val: &Secret<T>) -> Secret<T> {
    // This is a simplified implementation. Production code should use
    // bitwise operations to ensure constant-time execution.
    let mask = if cond.0 { !0u64 } else { 0u64 };
    let then_bits = unsafe { std::mem::transmute_copy::<T, u64>(&then_val.0) };
    let else_bits = unsafe { std::mem::transmute_copy::<T, u64>(&else_val.0) };
    let result_bits = (then_bits & mask) | (else_bits & !mask);
    Secret(unsafe { std::mem::transmute_copy::<u64, T>(&result_bits) })
}
"#;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::Lexer;
    use crate::parser::Parser;
    use crate::transform::to_oblivious;

    fn transpile(input: &str) -> String {
        let lexer = Lexer::new(input);
        let tokens: Vec<_> = lexer.filter_map(Result::ok).collect();
        let mut parser = Parser::new(&tokens);
        let ast = parser.parse().unwrap();
        let obli = to_oblivious(&ast);
        emit_rust(&obli)
    }

    #[test]
    fn test_simple_emit() {
        let code = transpile("1 + 2");
        assert!(code.contains("ct_add"));
    }

    #[test]
    fn test_secret_emit() {
        let code = transpile("secret(42)");
        assert!(code.contains("Secret::new"));
    }

    #[test]
    fn test_ct_select_emit() {
        let code = transpile("let x = secret(1) if x > 0 then secret(1) else secret(0)");
        assert!(code.contains("ct_select"));
    }
}
